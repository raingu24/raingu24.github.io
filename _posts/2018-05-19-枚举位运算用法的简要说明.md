[返回首页](/index.html)

#### 1. 在枚举中常用的位运算
  - 1.1 位左移
  ```
   在枚举中，常用的位移方式是左移。
  1 << 0 ==> 1  二进制的表示：0000 0001
  1 << 1 ==> 2  二进制的表示：0000 0010
  1 << 2 ==> 4  二进制的表示：0000 0100
  1 << 3 ==> 8  二进制的表示：0000 1000
  1 << 4 ==> 16 二进制的表示：0001 0000
  从上可以看出，左移的数学意义就是1 * 2^n，其中n为左移符号右侧的值。
```  
```
  1可以移动，其实任意数字都可以移动。其数学意义就是x * 2^n，x为任意正整数。例如：
  2 << 1 ==> 4  二进制的表示：0000 0100
  3 << 2 ==> 12 二进制的表示：0000 1100
``` 

  - 1.2 \|和&运算。正因为这种位运算的存在，枚举才会采用位运算的方式进行枚举值的定义。因为这种运算可以实现多个枚举值共存。
  
  ```
  typedef NS_OPTIONS(NSInteger, testEnum) {
      a = 1 << 0, // 0000 0001    1
      b = 1 << 1, // 0000 0010    2
      c = 1 << 2, // 0000 0100    4
      d = 1 << 3, // 0000 1000    8
  };
  
   testEnum e = a | b;
   if (e & a) {
       printf("满足条件a\n"); // 被打印
   }
   if (e & b) {
       printf("满足条件b\n"); // 被打印
   }
   if (e & c) {
       printf("满足条件c\n"); // 不打印
   }
   if (e & d) {
       printf("满足条件d\n"); // 不打印
   }
  // 以上代码可以这样去理解：如果有多个枚举值共同对一种情况进行描述，比如可以让一个滑动手势支持多个方向，那么或操作会得到一个值。在方法的实现文件中，当这个值和原枚举值进行与操作的时候，就可以判断是否包含有这个枚举值。从而实现多种情况描述。

  ```

  - 1.3 在实际应用中，可以对于不同的位区间去人为的规定。例如0-4位表示颜色，4-8位表示方向等等。这个完全是人为规定的。严谨一点，可以在每个部分开始的时候，用一些标记来说明。比如在RGModel中，使用RGEncodingTypeQualifierMas = 0xFF00这样的标记来急性分割。

  - 1.4 有一个小细节。如果在验证输出的时候，要注意控制台输出的格式化符。%lx代表的是十六进制的值。所以1 << 4它打印出来的值为10，相当于十进制的16。这个在实际验证的时候不要呆住了。
